// Generated by dts-bundle-generator v6.2.0

import { ClientSession, Document, Schema, Types } from 'mongoose';

export interface IAnyObject {
	[k: string]: any;
}
export interface ITransaction {
	_id?: Types.ObjectId;
	credit: number;
	debit: number;
	meta?: IAnyObject;
	datetime: Date;
	account_path: string[];
	accounts: string;
	book: string;
	memo: string;
	_journal: Types.ObjectId;
	timestamp: Date;
	voided?: boolean;
	void_reason?: string;
	_original_journal?: Types.ObjectId;
}
export declare function setTransactionSchema(schema: Schema, collection?: string, options?: {
	defaultIndexes: boolean;
}): void;
export declare type IFilterQuery = {
	account?: string | string[];
	_journal?: Types.ObjectId | string;
	start_date?: Date | string | number;
	end_date?: Date | string | number;
} & Partial<ITransaction> & {
	[key: string]: string[] | number | string | Date | boolean | Types.ObjectId;
};
export interface IPaginationQuery {
	perPage?: number;
	page?: number;
}
export declare type IBalanceQuery = {
	account?: string | string[];
	start_date?: Date | string | number;
	end_date?: Date | string | number;
} & {
	[key: string]: string[] | number | string | Date | boolean | Types.ObjectId | IAnyObject;
};
export interface IJournal {
	_id: Types.ObjectId;
	datetime: Date;
	memo: string;
	_transactions: Types.ObjectId[];
	book: string;
	voided?: boolean;
	void_reason?: string;
}
export declare type TJournalDocument<T extends IJournal = IJournal> = Omit<Document, "__v" | "id"> & T;
export declare function setJournalSchema(schema: Schema, collection?: string): void;
export declare type IOptions = {
	session?: ClientSession;
};
export declare class Entry<U extends ITransaction = ITransaction, J extends IJournal = IJournal> {
	book: Book;
	journal: TJournalDocument<J> & {
		_original_journal?: Types.ObjectId;
	};
	transactions: U[];
	timestamp: Date;
	static write<U extends ITransaction, J extends IJournal>(book: Book, memo: string, date: Date | null, original_journal?: string | Types.ObjectId): Entry<U, J>;
	constructor(book: Book, memo: string, date: Date | null, original_journal?: string | Types.ObjectId);
	private transact;
	credit<T extends IAnyObject = IAnyObject>(account_path: string | string[], amount: number | string, extra?: T & Partial<U>): Entry<U, J>;
	debit<T extends IAnyObject = IAnyObject>(account_path: string | string[], amount: number | string, extra?: T & Partial<U>): Entry<U, J>;
	commit(options?: IOptions & {
		writelockAccounts?: string[] | RegExp;
	}): Promise<Entry<U, J>["journal"]>;
}
export declare class Book<U extends ITransaction = ITransaction, J extends IJournal = IJournal> {
	name: string;
	precision: number;
	maxAccountPath: number;
	balanceSnapshotSec: number;
	expireBalanceSnapshotSec: number;
	constructor(name: string, options?: {
		precision?: number;
		maxAccountPath?: number;
		balanceSnapshotSec?: number;
		expireBalanceSnapshotSec?: number;
	});
	entry(memo: string, date?: Date, original_journal?: string | Types.ObjectId): Entry<U, J>;
	balance(query: IBalanceQuery, options?: IOptions): Promise<{
		balance: number;
		notes: number;
		debit: number;
		credit: number;
	}>;
	ledger<T = U>(query: IFilterQuery & IPaginationQuery, options?: IOptions): Promise<{
		results: T[];
		total: number;
	}>;
	void(journal_id: string | Types.ObjectId, reason?: undefined | string, options?: IOptions): Promise<Omit<import("mongoose").Document<any, any, any>, "id" | "__v"> & J & {
		_original_journal?: Types.ObjectId;
	}>;
	writelockAccounts(accounts: string[], options: Required<Pick<IOptions, "session">>): Promise<Book<U, J>>;
	listAccounts(options?: IOptions): Promise<string[]>;
}
export declare function setLockSchema(schema: Schema, collection?: string): void;
export declare function mongoTransaction<T = unknown>(fn: (session: ClientSession) => Promise<T>): Promise<any>;
export declare function initModels(): Promise<void>;
/**
 * Will execute mongoose model's `syncIndexes()` for all medici models.
 * WARNING! This will erase any custom (non-builtin) indexes you might have added.
 * @param [options] {{background: Boolean}}
 */
export declare function syncIndexes(options?: {
	background: boolean;
}): Promise<void>;
export declare class MediciError extends Error {
	code: number;
	constructor(message: string, code?: number);
}
export declare class BookConstructorError extends MediciError {
	code: number;
	constructor(message: string, code?: number);
}
export declare class InvalidAccountPathLengthError extends MediciError {
	code: number;
	constructor(message: string, code?: number);
}
export declare class JournalAlreadyVoidedError extends MediciError {
	code: number;
	constructor(message?: string, code?: number);
}
export declare class JournalNotFoundError extends MediciError {
	code: number;
	constructor(message?: string, code?: number);
}
export declare class TransactionError extends MediciError {
	code: number;
	total: number;
	constructor(message: string, total: number, code?: number);
}
export default Book;

export {};
